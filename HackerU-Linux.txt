Занятие 1 (Linux)

обычно ядро у всех дистрибутивов одинаковое

CAINE - дистрибутив для риминалистики и сбора улик

Под профильные задачи имеет смысл создавать профильные виртуальные машины, вместо того что бы ставить все проги на хост

В папке boot лежат файлы для запуска системы. В частности версия ядра для запуска системы до расшифроввывания диска 

папка bin содержит в себе исполняемые файлы 

папка etc - содержит

/etc/passwd - файл, содержащий основные данные о всех пользователях

Гайд по разделению диска: https://wiki.archlinux.org/index.php/partitioning

cd - 		//вернуться  в прошулю директорию

pushd .		//добавить папку в стак для быстрого перемещения
popd		//возвращаемся в последнюю точку из стака

ls -l		//подробный вывод
ls -a 		//скрытые файлы
ls -R 		//содержимое папок

ln <1st file> <2nd file>	//создаем ссылку на файл. Оба файла будут одинаковыми, но их можно хранить в разных местах

rm <опция> -- <аргумент> 	//два дефиса нужны для экранирования, чтоб имя файла не считалось за аргумент
rm <-rf> -- example.txt		//

ctrl-x ctrl-e			//редактируем команду в nano что бы было проще

mkdir -p newdir1/newdir2	//позволит создать директирию в директории
mkdir dir{1..4}			//создает 4 пронумерованные директории

cut -f<столбец> -d '<разделитель>' <имя файла> 		//разделяет текст на столбцы и выводит

scp -P <port> <file> user@127.0.0.1:/home/Desktop	//передача файлов по scp

grep -v <sth>	//исключить из вывода результаты содержащеие слово

tr -d "<symbol>"	//исключает символы из вывода
tr "<for replace>" "<replacement>"	//заменить символы при выводе
 



regexone.com
https://hackmd.io/@HackerU-csr/r1IAA1YSD
https://hackmd.io/@HackerU-csr/r1oh-QPgP
https://www.openvim.com/




Занятие 2 (Linux)
sudo bash -c "ls -l /root/ > /root/file.txt"

ls . >output.txt	//записать вывод работы программы в файл
2>errors.txt		//записать ошибки в файл
1>input.txt

grep <sth> file.txt		//можно и так грепать
grep -oP "регулярное выражение"

sed -i 's/<что заменяем>/<на что заменяем>/'

можно почитать книжку "sed и awk"

sort -u		//сортировка только уникальных вхождений
wc -l 		//подсчитать кол-во записей

overthewire.org/wargames/bandit		//еще площадка для практики пентеста/администрирования

find <где> -name <что>			//поиск файлов - в мане много прикольного

пройди vimtutor !

Vim
2D - удалить две строки


cmd1 || cmd2 || cmd3		//выполнилась ли команда? если нет пробуем команду 2...
cmd1 && cmd2 && cmd3		//если не выполинлась команда - дальнейшие не будут выполнены

cmd &				//запустить команду в background (firefox не будет жрать окно терминала!)
ctrl z				//закинуть рабочую прогу в background 
jobs				//показывает background процесы
bg <id>				//перекинуть прогу в background или frontbgound
kill				//снять задачу

tail -n<кол-во строк>

useradd - просто добавляет пользователя в конфиг
adduser - создает полноценного пользователя с домашней папкой, правами и т.п.

groups - отображает список груп (или в /etc/group)
addgroup - создаем группу
usermod -a -G <группа> <юзер>
gpasswd -d <user> <group>


bash script.sh		//позволяет нам вполнить скрипт без права на выполнение

chmod -x dir		//папка полностью закрыта (можно узнать только список названий)
chmod -w dir		//нельзя создавать/удалять файлы из папки, но можно редактировать
chmod -r dir 		//нельзя 

права на файл: читать, редактировать, запускать
правана папку: перемещать, переименовывать, смотреть содержимое,


/etc/skel - папка с контентом, который кладется в папку к каждому создаваемому пользователю


Занятие 3 (Linux)
vim ~/.profile - можем назначить umask по умолчанию
umask - величина, вычитаемая из прав создлаваемых файлов по умолчанию
umask <значение>	//установить новые права

если поставить ограничение от пользователя - они будут действовать на самого пользователя
если поставить ограничение от рута - они не будут действовать на него

chmod +x 	//права добавляются для всех пользователей
u - user
g - group
o - others
chmod ug +x	//права даем кому захотим
chmod o=	//отобрать права у всех остальных

для смены владельца файла нужны права суперпользователя

sudo chown <имя пользователя кому>:<его группа> <имя файла>

stat <файл> 	//подробная инфа о файле 

sudo chattr <+/-> i <file>	//настройка атрибутов файлов так, что с ним ничего не получится сделать
sudo chattr <+/-> a <file>	//в файл можно только добавлять информцию, но не редактировать/удалять (хорошо для логов)


nproc 		//кол-во загруженных ядер

в top процентаж осуществляется в привязке к ядрам (1 - 100%, 2 - 200%)


127.0.0.0/8 диапазон локальных адресов 

ip link set wlan0 up 	//ifconfig wlan0 up
ip addr add 172.16.1.1  //

idconfig wlan0 10.21.0.99 netmask 255.255.255.0		//настроить ip адрес на интерфейс

dhclient -r wlan0	//сбросить настройки 
dhclient -v 

/etc/resolv.conf	//файл для настройки dns


На машине с графическим интерфейсом предпочтительнее использовать интерфейс, а не команды

apt install		//более современный, но не стоит использовать в скриптах
apt-get install 	//более надежный
apt show <package>	//инфо об установленной программе


GitHub!

git clone <ссылка> 	//копирует контент в рабочую директорию

ДЗ - в LMS есть тест, прикрепеленный к заданию 2. Надо прорешать. Если вдруг мискликнул - пишем ярославу
в вопросе про (не?)интерактивные редакторы можно выбрать один из вариантов, система засчитает его за правильный



Занятие 4 (Linux)
wget <ссылка>		//качаем что-либо и сохраняем в виде файла
wget --noparent -r 	//качаем только папку 
man wget 		//интересные шаблоны

curl 			//чаще для диагностики/пентеста


sudo service --status-all	//показывает список сервисов и их статус

26 минута - интересная правка конфигов
пользователи ищут исполняемые файлы в разных местах

service <название> status	//проверка статуса сервиса
service <name> start		//запустить сервис
systemctl enable <name>	//добавить сервис в автозагрузку
systemctl disable <name>	//удалить сервис из автозагрузки

/etc/apache2/sites-enabled	//папка для веб страниц
/var/log/apache2		//папка с логами


telnet 23 - протокол для конфигурации устройств, которые не тянут ssh в локальной сети
ssh 22 - протокол для удаленного администрирования/передачи файлов/использования в качестве прокси/
ftp - для раздачи общедоступных файлов
samba - сервис зда расшаривания фалов
sftp - передача файлов в зашифрованном виде

ctrl + ] + exit - выйти из telnet

/etc/ssh/sshd_config		//можно настроить порты ssh (порт менять реально важно)
man sshd_config		//ман по конфигу ssh
перезапуск и остановка ssh влияет только на новые соединения. Если кто-то уже подключен, перезагрузка его не выкинет

sudo sshd -t 		//проверка конфигурации на работоспособность. Лучше проверить перед началом работы

!полезно! /.ssh/config		//можно создать "ярлыки" для ssh сессий, что бы не вводить все заново
netstat -t --inet		//проверка активных соединений

ssh-keygen		//ключи кладем в .ssh/authorized_keys
unzip <zipfile>

1:40 - ssh практика
+ пропала связь

sftp - один из лучших способов передачи файлов

scp <file> host:/<folder>
tab на ssh работает только через ключи. Через пароль работать не будет

sshfs - монтирует часть удаленной машины и позволяет работать с ней в редакторах





вся домашка принимается до 2.11




Занятие 5 (Linux)
https://hackmd.io/@7B8nSSkrTfeIlRl-YPZvdQ/hackeru-csr3-advanced-bash
https://hackmd.io/@7B8nSSkrTfeIlRl-YPZvdQ/hackeru-csr3-bash-examples
https://hackmd.io/@7B8nSSkrTfeIlRl-YPZvdQ/hackeru-csr3-bash

расширение скрипта не имеет значения, важно то, что написано в #!/bin/*

# - комментарий

для запуска бинарников (ака .exe) право на чтение не нужно
для запуска скриптов - право на чтение нужно

в системе есть большое количество глобальных переменных, необходимых для настройки отображения
язык, разрешение монитора, домашняя папка и т.п.

env 		//отображает все переменные окружения

$<переменные окружения>	//использовать переменную окружения

в Bash очень важно число пробелов!
табуляция в отличии от питона роли не играет
используем либо \n либо ; для разделения строк

присвоение переменной:
var=5
name="Adam"

'$name'	-> $name	//все что внутри - текст
"$name"	-> Adam	//можно в текст вставлять подстановки	

mydir=`pwd`		//подставляет вывод после использования команды 
mydir=$(pwd)		//то-же самое, только другой синтаксис

((1 + 1 * $var))	//математические операции в двойных скобках!

bc 		//калькулятор в командной строке

if <условие>;
	then <действие>
fi

$?		//переменная, отражающая статус выполнения прошлой команды 0 - успех 1,2 - отказ


<команда> > /dev/null		//подавление вывода 
grep -q			//опция -q часто есть в командах и она подавляет вывод

else		//как везде

elif		//как в питоне

[ $var -gt 5 ]		//условие переменная больше 5 ВАЖНЫ ВСЕ ПРОБЕЛЫ

-eq	// ==
-ge	// >=
-gt	// >
-le	// <=
-lt	// <
-ne	// !=

Bash не предназначен для работы с дробными числами!

[ $str1 = $str2 ]	//сравнение строк на эквивалентность

существует ряд условий, поределяющие, можно ли редактировать файли и т.п.


for <i> in <диапазон>
do
	<действие>
done


IFS=<символ>	//кастомный разделитель



number=10
while [ $number -gt 2 ]; do
	echo $number
	number=$(($number - 1))
done


(( a++ ))
(( --a ))


break		//прервать выполнение цикла и не начинать новую итерацию


exit 0		//завершение программы 
	

continue	//пропуск иттерации цикла


for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > output.txt		//перенаправление вывода


интерактивный ввод
$0 		//имя скрипта
$1,2,3...	//параметры из ввода

./script.sh param1 param2 param3


$#	//позволяет сравнивать не сами параметры, а их количество


seq 1 1000	//выводит диапазон чисел от 1 до 1000


read		//читаем ввод с консоли
read -p "please enter sth"	//приглашение
read -s	//для ввода паролей

read line 	//читаем строку из файла


exec 1>outfile.txt	//редеректим содержимое скрипта в файл вывода


sleep <sec>		//приостановка следующего процесса



functionName() {
}
 



